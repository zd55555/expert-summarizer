import React, { useState } from 'react';
import { Copy, Download, Send, Loader2, CheckCircle, Brain, Search, Save, AlertCircle } from 'lucide-react';

const YouPlusV2 = () => {
  const [content, setContent] = useState('');
  const [currentStep, setCurrentStep] = useState('input');
  const [useMemory, setUseMemory] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [zepError, setZepError] = useState(false);
  
  // Memory-related state
  const [queries, setQueries] = useState([]);
  const [memories, setMemories] = useState([]);
  const [memoryBites, setMemoryBites] = useState([]);
  const [selectedMemories, setSelectedMemories] = useState(new Set());
  const [showMemoryCreation, setShowMemoryCreation] = useState(false);
  
  // Analysis state
  const [analysis, setAnalysis] = useState(null);
  const [copied, setCopied] = useState(false);
  const [followUpLoading, setFollowUpLoading] = useState(null);
  const [chatMessage, setChatMessage] = useState('');
  const [chatLoading, setChatLoading] = useState(false);
  const [completedActions, setCompletedActions] = useState(new Set());
  const [needsLogin, setNeedsLogin] = useState(false);

  // Placeholder Zep API functions
  const searchZepMemories = async (searchQueries) => {
    try {
      // Placeholder for Netlify Function call to /netlify/functions/zep-search
      const response = await fetch('/.netlify/functions/zep-search', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queries: searchQueries })
      });
      
      if (!response.ok) throw new Error('Zep search failed');
      
      const data = await response.json();
      return data.memories || [];
    } catch (err) {
      console.error('Zep search error:', err);
      throw new Error('Zep is currently unavailable');
    }
  };

  const saveZepMemories = async (memoriesToSave) => {
    try {
      // Placeholder for Netlify Function call to /netlify/functions/zep-save
      const response = await fetch('/.netlify/functions/zep-save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ memories: memoriesToSave })
      });
      
      if (!response.ok) throw new Error('Zep save failed');
      
      return await response.json();
    } catch (err) {
      console.error('Zep save error:', err);
      throw new Error('Failed to save memories to Zep');
    }
  };

  const generateQueries = async () => {
    setLoading(true);
    setError('');
    
    const prompt = `You are a research strategist. Analyze this content and generate 3-5 precise questions that should be asked of a personal knowledge database to gather relevant context.

Focus on:
- Key people, organizations, or entities mentioned
- Similar topics, projects, or situations from the past
- Related decisions, outcomes, or lessons learned
- Background context that would inform analysis

Return ONLY a JSON array of query strings, nothing else.

Content to analyze:
${content}`;

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1000,
          messages: [{ role: "user", content: prompt }]
        })
      });

      if (!response.ok) {
        throw new Error(`Query generation failed: ${response.status}`);
      }

      const data = await response.json();
      let responseText = data.content[0].text.trim();
      
      // Clean up response to get just the JSON
      responseText = responseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
      
      const generatedQueries = JSON.parse(responseText);
      setQueries(generatedQueries);
      setCurrentStep('queries');
    } catch (err) {
      if (err.message.includes('404') || err.message.includes('401') || err.message.includes('403')) {
        setNeedsLogin(true);
        setError('');
      } else {
        setError(`Error generating queries: ${err.message}`);
      }
    } finally {
      setLoading(false);
    }
  };

  const handleSearchMemory = async () => {
    setLoading(true);
    setZepError(false);
    
    try {
      const retrievedMemories = await searchZepMemories(queries);
      
      if (retrievedMemories.length === 0) {
        setMemories(['No relevant memories found in your knowledge graph.']);
      } else {
        setMemories(retrievedMemories);
      }
      
      setCurrentStep('memories');
    } catch (err) {
      setZepError(true);
      setMemories(['Zep is currently unavailable. Proceeding with regular analysis.']);
      setCurrentStep('memories');
    } finally {
      setLoading(false);
    }
  };

  const analyzeContent = async (includeMemoryContext = false) => {
    setLoading(true);
    setError('');
    
    let contextSection = '';
    if (includeMemoryContext && memories.length > 0 && !memories[0].includes('No relevant memories') && !memories[0].includes('currently unavailable')) {
      contextSection = `\n\nRELEVANT CONTEXT FROM YOUR KNOWLEDGE GRAPH:\n${memories.join('\n')}\n\nUse this context to inform your analysis when relevant, but focus on the current content.`;
    }
    
    const prompt = `You are a Meeting Transcript Expert who transforms raw content into comprehensive professional analysis using a four-phase system.

## CORE PROCESS

**Phase 1: Content Summary** - Extract key information objectively with concise overview
**Phase 2: Expert Identification** - Determine what type of professional expert would provide the most value  
**Phase 3: Expert Analysis** - Assume that expert role and provide specialized insights
**Phase 4: Action Assistance** - Offer numbered options to help complete specific next steps

## INSTRUCTIONS

### Phase 1: Create Content Summary
- Start with 3 sentences maximum stating what type of content this is and key context
- Extract main topics, decisions, and action items using bullet points only
- Identify participant roles, expertise levels, and key contributions (for meetings)
- Note organizational context, constraints, and underlying objectives that emerge
- Document explicit commitments, timelines, and success criteria mentioned
- HARD LIMIT: Keep entire summary under 200 words regardless of input length

### Phase 2: Identify Expert Persona
- Analyze content themes, challenges, and decision points to determine most relevant professional domain
- Consider the content type and context when selecting expert type
- Choose specific expert role(s) that would provide maximum value for this situation
- OUTPUT: One sentence maximum identifying the expert persona(s) you're adopting

### Phase 3: Provide Expert Analysis
- Assume the role of identified expert completely, drawing on professional training and experience
- Identify what was said "between the lines" but not explicitly discussed
- Analyze content effectiveness and decision quality from expert perspective
- Highlight professional insights only a trained expert in that field would recognize
- Recommend domain-specific resources, frameworks, and methodologies
- Suggest strategic questions that would deepen understanding and improve outcomes

### Phase 4: Offer Action Assistance  
- Review specific action items and deliverables identified in previous phases
- Offer numbered options to help complete concrete next steps immediately
- Consider task dependencies and optimal sequencing when presenting options
- Ask minimal clarifying questions about format preferences when needed
- Leverage expert knowledge to suggest appropriate templates and approaches
- Make it easy for users to simply say "do number X" to get started

## OUTPUT FORMAT

Structure every response using this exact format:

## PHASE 1: CONTENT SUMMARY

**CONTENT TYPE & CONTEXT**
[3 sentences maximum stating what type of content this is and key context]

**KEY INFORMATION**
• [Key point/decision with owner and deadline if applicable]
• [Key point/decision with owner and deadline if applicable]
• [Key point/decision with owner and deadline if applicable]

**PARTICIPANT CONTRIBUTIONS** (if applicable)
[Notable insights, concerns, or perspectives from participants]

---

## PHASE 2: EXPERT IDENTIFICATION

[One sentence identifying the expert persona(s) you're adopting for this analysis]

---

## PHASE 3: EXPERT ANALYSIS

*Speaking as [Expert Persona]*

**PROFESSIONAL INSIGHTS**
[What a trained professional would observe that participants missed]

**READING BETWEEN THE LINES**
[Subtext, patterns, or underlying issues only an expert would recognize]

**CRITICAL GAPS**
[Important topics that should have been discussed from expert perspective]

**RECOMMENDED RESOURCES**
[Specific frameworks, tools, methodologies relevant to their situation]

**EXPERT RECOMMENDATIONS**
[Professional next steps beyond what participants would think of]

**STRATEGIC QUESTIONS**
[Probing questions an expert would ask to deepen understanding]

---

## PHASE 4: ACTION ASSISTANCE

*Continuing as [Expert Persona]*

**IMMEDIATE ASSISTANCE OFFERS**
Based on the analysis above, I can help you get started on several tasks right now:

1. **[Specific action item]** - [Brief description with 2-3 format/preference options]
2. **[Specific action item]** - [Brief description with 2-3 format/preference options]  
3. **[Specific action item]** - [Brief description with 2-3 format/preference options]
4. **Generate Memory Bites** - Create structured memories to save to your knowledge graph

**EXPERT TOOLS AVAILABLE**
5. **[Expert-specific deliverable]** - [Format options]
6. **[Expert-specific deliverable]** - [Format options]

**READY TO START?**
Just tell me which number you'd like me to work on, and I'll create it immediately.

## QUALITY STANDARDS

- **Content Intelligence**: Infer content type, purpose, and context from submitted material alone
- **Concise Summary**: Keep Phase 1 under 200 words to maximize expert analysis depth
- **Brief Expert ID**: Phase 2 should be one sentence maximum for user confirmation
- **Authority in Phase 3**: Write with the depth and insight of a trained professional
- **Actionability in Phase 4**: Always include numbered options users can easily select
- **Professional Depth**: Provide insights only someone with formal training would offer
- **Clarity**: Use clear, professional language without unnecessary formatting
- **Token Optimization**: Prioritize expert insights and actionable guidance over verbose summaries
- **Unclear Content**: Make best-effort interpretations rather than requesting clarification

Take a deep breath and provide thorough, professional analysis that users would find genuinely valuable.

Here is the content to analyze:${contextSection}

${content}`;

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 4000,
          messages: [{ role: "user", content: prompt }]
        })
      });

      if (!response.ok) {
        throw new Error(`Analysis failed: ${response.status}`);
      }

      const data = await response.json();
      const analysisResult = data.content[0].text;
      
      const sections = parseAnalysis(analysisResult);
      setAnalysis({ raw: analysisResult, sections });
      setCurrentStep('analysis');
    } catch (err) {
      if (err.message.includes('404') || err.message.includes('401') || err.message.includes('403')) {
        setNeedsLogin(true);
        setError('');
      } else {
        setError(`Error analyzing content: ${err.message}`);
        setNeedsLogin(false);
      }
    } finally {
      setLoading(false);
    }
  };

  const parseAnalysis = (text) => {
    const sections = {};
    const phases = text.split(/## PHASE \d+:/);
    
    for (let i = 1; i < phases.length; i++) {
      const phaseContent = phases[i];
      const lines = phaseContent.split('\n');
      const title = lines[0]?.trim() || `Phase ${i}`;
      
      sections[`phase${i}`] = {
        title: title,
        content: phaseContent,
        raw: phaseContent
      };
    }

    if (sections.phase4) {
      const actionRegex = /(\d+)\.\s+\*\*(.+?)\*\*\s*-\s*(.+?)(?=\n\d+\.|$)/gs;
      const actions = [];
      let actionMatch;
      
      while ((actionMatch = actionRegex.exec(sections.phase4.content)) !== null) {
        actions.push({
          number: actionMatch[1],
          title: actionMatch[2],
          description: actionMatch[3].replace(/\n/g, ' ').trim()
        });
      }
      
      sections.phase4.actions = actions;
    }

    return sections;
  };

  const handleActionClick = async (actionNumber, actionTitle) => {
    if (actionTitle === "Generate Memory Bites") {
      await generateMemoryBites();
      return;
    }

    setFollowUpLoading(actionNumber);
    
    const followUpPrompt = `Continue as the expert persona from the previous analysis. The user has selected action item #${actionNumber}: "${actionTitle}". 

Please create this deliverable immediately with these requirements:
- Use your expert knowledge to create a professional, complete output
- Provide 2-3 format options when appropriate  
- Make it immediately useful and actionable
- Include specific details relevant to their content context

Create the deliverable now:`;

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2000,
          messages: [
            { role: "user", content: analysis.raw },
            { role: "assistant", content: "I've completed the four-phase analysis of your content." },
            { role: "user", content: followUpPrompt }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`Follow-up failed: ${response.status}`);
      }

      const data = await response.json();
      const deliverable = data.content[0].text;
      
      setAnalysis(prev => ({
        ...prev,
        deliverables: {
          ...prev.deliverables || {},
          [actionNumber]: {
            title: actionTitle,
            content: deliverable
          }
        }
      }));
      
      setCompletedActions(prev => new Set([...prev, actionNumber]));
    } catch (err) {
      if (err.message.includes('404') || err.message.includes('401') || err.message.includes('403')) {
        setNeedsLogin(true);
        setError('');
      } else {
        setError(`Error creating deliverable: ${err.message}`);
      }
    } finally {
      setFollowUpLoading(null);
    }
  };

  const generateMemoryBites = async () => {
    setFollowUpLoading('memory');
    
    const memoryPrompt = `Based on the entire session so far (the original content, any retrieved context, and the expert analysis), generate a list of concise, factual, 'memory-friendly' statements.

Each statement must be:
- A self-contained fact
- Specific and actionable
- Worth remembering for future reference
- Clear without additional context

Generate 4-7 memory statements and output them as a valid JSON array of strings. Do not add any conversational filler. Output only the JSON array.`;

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1000,
          messages: [
            { role: "user", content: analysis.raw },
            { role: "assistant", content: "I've completed the analysis of your content." },
            { role: "user", content: memoryPrompt }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`Memory generation failed: ${response.status}`);
      }

      const data = await response.json();
      let responseText = data.content[0].text.trim();
      responseText = responseText.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
      
      const generatedMemories = JSON.parse(responseText);
      setMemoryBites(generatedMemories);
      setSelectedMemories(new Set(generatedMemories.map((_, index) => index)));
      setShowMemoryCreation(true);
      
      setCompletedActions(prev => new Set([...prev, 'memory']));
    } catch (err) {
      if (err.message.includes('404') || err.message.includes('401') || err.message.includes('403')) {
        setNeedsLogin(true);
        setError('');
      } else {
        setError(`Error generating memory bites: ${err.message}`);
      }
    } finally {
      setFollowUpLoading(null);
    }
  };

  const handleChatMessage = async () => {
    if (!chatMessage.trim()) return;
    
    setChatLoading(true);
    
    const chatPrompt = `Continue as the expert persona from the previous analysis. The user has asked: "${chatMessage}"

Please respond as the expert, using your knowledge of their content context and analysis. Provide helpful, actionable guidance.`;

    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1500,
          messages: [
            { role: "user", content: analysis.raw },
            { role: "assistant", content: "I've completed the four-phase analysis of your content." },
            { role: "user", content: chatPrompt }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`Chat failed: ${response.status}`);
      }

      const data = await response.json();
      const chatResponse = data.content[0].text;
      
      const chatId = `chat_${Date.now()}`;
      setAnalysis(prev => ({
        ...prev,
        deliverables: {
          ...prev.deliverables || {},
          [chatId]: {
            title: `Question: ${chatMessage}`,
            content: chatResponse
          }
        }
      }));
      
      setChatMessage('');
    } catch (err) {
      if (err.message.includes('404') || err.message.includes('401') || err.message.includes('403')) {
        setNeedsLogin(true);
        setError('');
      } else {
        setError(`Error with chat: ${err.message}`);
      }
    } finally {
      setChatLoading(false);
    }
  };

  const handleSaveMemories = async () => {
    setLoading(true);
    const memoriesToSave = memoryBites.filter((_, index) => selectedMemories.has(index));
    
    try {
      await saveZepMemories(memoriesToSave);
      setShowMemoryCreation(false);
      
      // Add success message to deliverables
      const successId = `memory_success_${Date.now()}`;
      setAnalysis(prev => ({
        ...prev,
        deliverables: {
          ...prev.deliverables || {},
          [successId]: {
            title: "✅ Memories Saved Successfully",
            content: `${memoriesToSave.length} memories have been saved to your knowledge graph and will be available for future sessions.`
          }
        }
      }));
    } catch (err) {
      setError(`Error saving memories: ${err.message}`);
    } finally {
      setLoading(false);
    }
  };

  const toggleMemorySelection = (index) => {
    const newSelected = new Set(selectedMemories);
    if (newSelected.has(index)) {
      newSelected.delete(index);
    } else {
      newSelected.add(index);
    }
    setSelectedMemories(newSelected);
  };

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(analysis.raw);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      setError('Failed to copy to clipboard');
    }
  };

  const downloadAnalysis = () => {
    const blob = new Blob([analysis.raw], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'youplus-v2-analysis.md';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const formatContent = (content) => {
    return content
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/^• (.+)$/gm, '<li>$1</li>')
      .replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/^(.+)$/gm, '<p>$1</p>')
      .replace(/<p><\/p>/g, '');
  };

  return (
    <div className="max-w-4xl mx-auto p-6 bg-white min-h-screen">
      {/* Header */}
      <div className="mb-8 text-center">
        <h1 className="text-4xl font-bold text-gray-900 mb-3">🧠 YouPlus v2</h1>
        <p className="text-lg text-gray-600 max-w-3xl mx-auto">
          Cognitive Workbench Edition: Transform content into expert insights while building your personal knowledge graph
        </p>
      </div>

      {/* Input Section */}
      {currentStep === 'input' && (
        <div className="space-y-6">
          <div className="bg-gray-50 p-6 rounded-xl border border-gray-200">
            <label className="block text-lg font-semibold text-gray-800 mb-3">
              📝 Paste Your Content
            </label>
            <textarea
              value={content}
              onChange={(e) => setContent(e.target.value)}
              placeholder="Paste any content here: meeting transcripts, email drafts, reports, brainstorming notes, research papers, customer feedback, interview notes, or strategic documents."
              className="w-full h-48 p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none text-gray-700 bg-white"
            />
          </div>

          {content.length > 50 && (
            <div className="bg-blue-50 p-6 rounded-xl border border-blue-200">
              <h3 className="text-xl font-semibold text-blue-900 mb-4">Choose Your Analysis Approach:</h3>
              <div className="grid md:grid-cols-2 gap-4">
                <button
                  onClick={() => {
                    setUseMemory(true);
                    generateQueries();
                  }}
                  disabled={loading}
                  className="p-6 bg-white border-2 border-blue-200 rounded-lg hover:border-blue-400 transition-all text-left group disabled:opacity-50"
                >
                  <div className="flex items-center gap-3 mb-3">
                    <Brain className="w-6 h-6 text-blue-600" />
                    <span className="text-lg font-semibold text-blue-900">Enhanced with Memory</span>
                  </div>
                  <p className="text-gray-600">
                    Search your knowledge graph for relevant context, then provide analysis enriched with your historical insights.
                  </p>
                  <p className="text-sm text-blue-600 mt-2 group-hover:text-blue-800">
                    Best for: Complex decisions, recurring topics, building on past conversations
                  </p>
                </button>

                <button
                  onClick={() => {
                    setUseMemory(false);
                    analyzeContent(false);
                  }}
                  disabled={loading}
                  className="p-6 bg-white border-2 border-gray-200 rounded-lg hover:border-gray-400 transition-all text-left group disabled:opacity-50"
                >
                  <div className="flex items-center gap-3 mb-3">
                    <Search className="w-6 h-6 text-gray-600" />
                    <span className="text-lg font-semibold text-gray-900">Quick Analysis</span>
                  </div>
                  <p className="text-gray-600">
                    Immediate expert analysis without searching historical context. Still offers memory creation afterward.
                  </p>
                  <p className="text-sm text-gray-600 mt-2 group-hover:text-gray-800">
                    Best for: New topics, time-sensitive analysis, one-off content
                  </p>
                </button>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Loading States */}
      {loading && (
        <div className="text-center py-12">
          <Loader2 className="w-8 h-8 animate-spin mx-auto mb-4 text-blue-600" />
          <p className="text-gray-600">
            {currentStep === 'input' && useMemory ? 'Generating research queries...' :
             currentStep === 'input' && !useMemory ? 'Analyzing content...' :
             currentStep === 'queries' ? 'Searching your knowledge graph...' :
             currentStep === 'memories' ? 'Running enhanced analysis...' :
             'Saving memories...'}
          </p>
        </div>
      )}

      {/* Query Generation Results */}
      {currentStep === 'queries' && !loading && (
        <div className="bg-green-50 border-l-4 border-green-500 p-6 rounded-r-lg shadow-sm">
          <h2 className="text-2xl font-bold text-green-900 mb-4">📋 Generated Research Queries</h2>
          <p className="text-green-800 mb-4">Claude identified these topics to search in your knowledge graph:</p>
          
          <div className="bg-white p-4 rounded-lg border border-green-200 mb-4">
            {queries.map((query, index) => (
              <div key={index} className="flex items-center gap-2 mb-2 last:mb-0">
                <span className="text-green-600">•</span>
                <span className="text-gray-800">{query}</span>
              </div>
            ))}
          </div>

          <button
            onClick={handleSearchMemory}
            className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium"
          >
            Search My Memory
          </button>
        </div>
      )}

      {/* Memory Retrieval Results */}
      {currentStep === 'memories' && !loading && (
        <div className="space-y-6">
          <div className="bg-green-50 border-l-4 border-green-500 p-6 rounded-r-lg shadow-sm">
            <h2 className="text-2xl font-bold text-green-900 mb-4">📋 Generated Research Queries</h2>
            <div className="bg-white p-4 rounded-lg border border-green-200">
              {queries.map((query, index) => (
                <div key={index} className="flex items-center gap-2 mb-2 last:mb-0">
                  <span className="text-green-600">•</span>
                  <span className="text-gray-800">{query}</span>
                </div>
              ))}
            </div>
          </div>

          <div className="bg-purple-50 border-l-4 border-purple-500 p-6 rounded-r-lg shadow-sm">
            <h2 className="text-2xl font-bold text-purple-900 mb-4">🔍 Retrieved Memories</h2>
            {zepError && (
              <div className="flex items-center gap-2 mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
                <AlertCircle className="w-5 h-5 text-yellow-600" />
                <p className="text-yellow-800">Zep is currently unavailable. Proceeding with regular analysis.</p>
              </div>
            )}
            
            <div className="space-y-3">
              {memories.map((memory, index) => (
                <div key={index} className={`p-4 rounded-lg border ${
                  memory.includes('No relevant memories') || memory.includes('currently unavailable') 
                    ? 'bg-gray-50 border-gray-200' 
                    : 'bg-white border-purple-200'
                }`}>
                  <p className="text-gray-800">{memory}</p>
                </div>
              ))}
            </div>

            <button
              onClick={() => analyzeContent(true)}
              className="mt-6 px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors font-medium"
            >
              {memories[0]?.includes('No relevant memories') || memories[0]?.includes('currently unavailable')
                ? 'Run Regular Analysis' 
                : 'Run Enhanced Analysis'}
            </button>
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-red-700 font-medium">⚠️ {error}</p>
        </div>
      )}

      {/* Login Required Prompt */}
      {needsLogin && (
        <div className="mb-6 p-6 bg-blue-50 border-2 border-blue-200 rounded-lg">
          <div className="text-center">
            <h3 className="text-xl font-semibold text-blue-900 mb-3">🔐 Login Required</h3>
            <p className="text-blue-800 mb-4">
              To use YouPlus v2 with Claude's AI intelligence, you need to be logged into Claude.
            </p>
            <p className="text-blue-700 text-sm mb-6">
              This app uses Claude's expert analysis capabilities. Your usage will count against your Claude plan.
            </p>
            
            <div className="space-y-3">
              <button
                onClick={() => {
                  window.open('https://claude.ai/login', '_blank');
                  setNeedsLogin(false);
                  setError('After logging in, please return to this tab and try again.');
                }}
                className="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Login to Claude
              </button>
              
              <div className="text-sm text-blue-600">
                <p>Don't have a Claude account? <a href="https://claude.ai/signup" target="_blank" rel="noopener noreferrer" className="underline hover:text-blue-800">Sign up for free</a></p>
              </div>
              
              <button
                onClick={() => {
                  setNeedsLogin(false);
                  setError('');
                }}
                className="block mx-auto text-blue-600 hover:text-blue-800 text-sm underline"
              >
                I'm already logged in - try again
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Analysis Results */}
      {currentStep === 'analysis' && analysis && (
        <div className="space-y-8">
          {/* Export Options */}
          <div className="flex gap-3 pb-6 border-b border-gray-200">
            <button
              onClick={copyToClipboard}
              className="flex items-center gap-2 px-5 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors font-medium"
            >
              {copied ? <CheckCircle className="w-5 h-5 text-green-600" /> : <Copy className="w-5 h-5" />}
              {copied ? '✅ Copied!' : '📋 Copy Analysis'}
            </button>
            <button
              onClick={downloadAnalysis}
              className="flex items-center gap-2 px-5 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors font-medium"
            >
              <Download className="w-5 h-5" />
              💾 Download
            </button>
          </div>

          {/* Show memory context if it was used */}
          {useMemory && memories.length > 0 && !memories[0].includes('No relevant memories') && !memories[0].includes('currently unavailable') && (
            <div className="bg-purple-50 border-l-4 border-purple-500 p-6 rounded-r-lg shadow-sm">
              <h3 className="text-lg font-bold text-purple-900 mb-3">🔍 Memory Context Used</h3>
              <div className="space-y-2">
                {memories.slice(0, 3).map((memory, index) => (
                  <div key={index} className="bg-white p-3 rounded border border-purple-200 text-sm">
                    <p className="text-gray-700">{memory}</p>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Phase 1: Content Summary */}
          {analysis.sections.phase1 && (
            <div className="bg-blue-50 border-l-4 border-blue-500 p-6 rounded-r-lg shadow-sm">
              <h2 className="text-2xl font-bold text-blue-900 mb-4 flex items-center gap-2">
                📊 Phase 1: Content Summary
              </h2>
              <div 
                className="prose prose-blue max-w-none text-gray-700"
                dangerouslySetInnerHTML={{ __html: formatContent(analysis.sections.phase1.content) }}
              />
            </div>
          )}

          {/* Phase 2: Expert Identification */}
          {analysis.sections.phase2 && (
            <div className="bg-green-50 border-l-4 border-green-500 p-6 rounded-r-lg shadow-sm">
              <h2 className="text-2xl font-bold text-green-900 mb-4 flex items-center gap-2">
                🎯 Phase 2: Expert Identification
              </h2>
              <div 
                className="prose prose-green max-w-none text-gray-700"
                dangerouslySetInnerHTML={{ __html: formatContent(analysis.sections.phase2.content) }}
              />
            </div>
          )}

          {/* Phase 3: Expert Analysis */}
          {analysis.sections.phase3 && (
            <div className="bg-purple-50 border-l-4 border-purple-500 p-6 rounded-r-lg shadow-sm">
              <h2 className="text-2xl font-bold text-purple-900 mb-4 flex items-center gap-2">
                🧠 Phase 3: Expert Analysis {useMemory && !memories[0]?.includes('No relevant memories') && !memories[0]?.includes('currently unavailable') && '(Enhanced with Memory)'}
              </h2>
              <div 
                className="prose prose-purple max-w-none text-gray-700"
                dangerouslySetInnerHTML={{ __html: formatContent(analysis.sections.phase3.content) }}
              />
            </div>
          )}

          {/* Phase 4: Action Assistance */}
          {analysis.sections.phase4 && (
            <div className="bg-orange-50 border-l-4 border-orange-500 p-6 rounded-r-lg shadow-sm">
              <h2 className="text-2xl font-bold text-orange-900 mb-4 flex items-center gap-2">
                ⚡ Phase 4: Action Assistance
              </h2>
              
              {/* Interactive Action Buttons */}
              {analysis.sections.phase4.actions && analysis.sections.phase4.actions.length > 0 && (
                <div className="space-y-4">
                  <h3 className="text-lg font-semibold text-gray-900">
                    Get Started Now:
                  </h3>
                  <div className="grid gap-3">
                    {analysis.sections.phase4.actions.map((action) => {
                      const isCompleted = completedActions.has(action.number) || (action.title === "Generate Memory Bites" && completedActions.has('memory'));
                      const isLoading = followUpLoading === action.number || (action.title === "Generate Memory Bites" && followUpLoading === 'memory');
                      
                      return (
                        <button
                          key={action.number}
                          onClick={() => !isCompleted && handleActionClick(action.number, action.title)}
                          disabled={isLoading || isCompleted}
                          className={`flex items-center justify-between p-4 border-2 rounded-lg transition-all text-left ${
                            isCompleted 
                              ? 'bg-green-50 border-green-200 text-green-800' 
                              : 'bg-white border-orange-200 hover:bg-orange-25 hover:border-orange-300'
                          } ${isCompleted ? 'cursor-default' : 'cursor-pointer'} shadow-sm hover:shadow-md`}
                        >
                          <div className="flex-1">
                            <span className={`font-semibold text-lg flex items-center gap-2 ${
                              isCompleted ? 'text-green-800' : 'text-orange-900'
                            }`}>
                              {isCompleted && '✅ '}
                              #{action.number}: {action.title}
                              {isCompleted && ' (Completed)'}
                            </span>
                            <p className={isCompleted ? 'text-green-600 mt-1' : 'text-gray-600 mt-1'}>
                              {action.description}
                            </p>
                          </div>
                          {isLoading && (
                            <Loader2 className="w-6 h-6 animate-spin text-orange-600 ml-3" />
                          )}
                        </button>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Memory Creation Interface */}
          {showMemoryCreation && (
            <div className="bg-orange-50 border-l-4 border-orange-500 p-6 rounded-r-lg shadow-sm">
              <h2 className="text-2xl font-bold text-orange-900 mb-4">💾 Save to Knowledge Graph</h2>
              <p className="text-orange-800 mb-4">Select which insights to save to your personal knowledge graph:</p>
              
              <div className="space-y-3">
                {memoryBites.map((bite, index) => (
                  <label key={index} className="flex items-start gap-3 p-4 bg-white rounded-lg border border-orange-200 hover:bg-orange-25 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={selectedMemories.has(index)}
                      onChange={() => toggleMemorySelection(index)}
                      className="mt-1 w-5 h-5 text-orange-600 rounded focus:ring-orange-500"
                    />
                    <span className="text-gray-800 flex-1">{bite}</span>
                  </label>
                ))}
              </div>

              <div className="mt-6 flex items-center gap-4">
                <button
                  onClick={handleSaveMemories}
                  disabled={selectedMemories.size === 0 || loading}
                  className="px-6 py-3 bg-orange-600 text-white rounded-lg hover:bg-orange-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors font-medium flex items-center gap-2"
                >
                  {loading ? <Loader2 className="w-5 h-5 animate-spin" /> : <Save className="w-5 h-5" />}
                  Save {selectedMemories.size} Selected Memories
                </button>
                <button
                  onClick={() => setShowMemoryCreation(false)}
                  className="px-6 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors font-medium"
                >
                  Cancel
                </button>
                <p className="text-gray-600 text-sm">
                  {selectedMemories.size} of {memoryBites.length} memories selected
                </p>
              </div>
            </div>
          )}

          {/* Generated Deliverables */}
          {analysis.deliverables && Object.keys(analysis.deliverables).length > 0 && (
            <div className="space-y-6">
              <h2 className="text-2xl font-bold text-gray-900 flex items-center gap-2">
                📋 Generated Deliverables
              </h2>
              {Object.entries(analysis.deliverables).map(([number, deliverable]) => (
                <div key={number} className="bg-gray-50 border-2 border-gray-200 p-6 rounded-lg shadow-sm">
                  <h3 className="text-xl font-semibold text-gray-900 mb-4 flex items-center gap-2">
                    ✅ {deliverable.title}
                  </h3>
                  <div 
                    className="prose max-w-none text-gray-700"
                    dangerouslySetInnerHTML={{ __html: formatContent(deliverable.content) }}
                  />
                </div>
              ))}
            </div>
          )}

          {/* Continue with Actions & Chat */}
          {analysis.sections.phase4 && (
            <div className="bg-orange-50 border-2 border-orange-200 p-6 rounded-lg shadow-sm">
              <h3 className="text-xl font-semibold text-orange-900 mb-4">Continue with More Actions:</h3>
              
              {/* Show original action buttons with completion status */}
              {analysis.sections.phase4.actions && (
                <div className="grid gap-3 mb-6">
                  {analysis.sections.phase4.actions.map((action) => {
                    const isCompleted = completedActions.has(action.number) || (action.title === "Generate Memory Bites" && completedActions.has('memory'));
                    const isLoading = followUpLoading === action.number || (action.title === "Generate Memory Bites" && followUpLoading === 'memory');
                    
                    return (
                      <button
                        key={action.number}
                        onClick={() => !isCompleted && handleActionClick(action.number, action.title)}
                        disabled={isLoading || isCompleted}
                        className={`flex items-center justify-between p-4 border-2 rounded-lg transition-all text-left ${
                          isCompleted 
                            ? 'bg-green-50 border-green-200 text-green-800' 
                            : 'bg-white border-orange-200 hover:bg-orange-25 hover:border-orange-300'
                        } ${isCompleted ? 'cursor-default' : 'cursor-pointer'} shadow-sm hover:shadow-md`}
                      >
                        <div className="flex-1">
                          <span className={`font-semibold text-lg flex items-center gap-2 ${
                            isCompleted ? 'text-green-800' : 'text-orange-900'
                          }`}>
                            {isCompleted && '✅ '}
                            #{action.number}: {action.title}
                            {isCompleted && ' (Completed)'}
                          </span>
                          <p className={isCompleted ? 'text-green-600 mt-1' : 'text-gray-600 mt-1'}>
                            {action.description}
                          </p>
                        </div>
                        {isLoading && (
                          <Loader2 className="w-6 h-6 animate-spin text-orange-600 ml-3" />
                        )}
                      </button>
                    );
                  })}
                </div>
              )}

              {/* Chat Interface */}
              <div>
                <h4 className="font-medium text-gray-900 mb-3">Ask the Expert:</h4>
                <div className="flex gap-3">
                  <input
                    type="text"
                    value={chatMessage}
                    onChange={(e) => setChatMessage(e.target.value)}
                    placeholder="Ask any question about your content or request a specific deliverable..."
                    className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    onKeyPress={(e) => e.key === 'Enter' && !chatLoading && handleChatMessage()}
                  />
                  <button
                    onClick={handleChatMessage}
                    disabled={chatLoading || !chatMessage.trim()}
                    className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 transition-colors flex items-center gap-2"
                  >
                    {chatLoading ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      <Send className="w-4 h-4" />
                    )}
                    Ask
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Footer */}
      <div className="mt-16 pt-8 border-t border-gray-200 text-center text-gray-500">
        <p>YouPlus v2: Cognitive Workbench Edition • Transform content into expert insights while building your knowledge graph</p>
      </div>
    </div>
  );
};

export default YouPlusV2;
